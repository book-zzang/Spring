## 스프링 부트

- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 앱 쉽게 생성

  예전에는 따로 웹서버 설치해서 해당 경로에 빌드 된 결과물 넣는 등 복잡했음

- 손 쉬운 빌드 구성을 위한 스타터 종속성 제공
- 스프링과 써드파티 라이브러리 자동 구성

  버전에 대해 신경쓰지 않아도 됨

- 메트릭, 상태확인, 외부구성 같은 프로덕션 준비 기능 제공

  운영환경에서의 모니터링 등

- 관례에 의한 간결한 설정

## 스프링의 핵심 개념

- 자바 언어 기반 프레임워크

  자바 : 객체 지향 언어

- 스프링 : 좋은 객체 지향 앱을 개발할 수 있게 도와주는 프레임워크

## 좋은 객체 지향 프로그래밍이란?

- 객체 지향 특징 : 추상화, 캡슐화, 상속, 다형성
- 객체지향프로그래밍 : 객체들의 모임/협력/유연하고 변경이 용이
- 다형성 예시 1

  자동차 역할(인터페이스) - 자동차 구현(구현체)

  운전자는 자동차 인터페이스만 알면 됨(구현체가 바뀌더라도 운전 모두 가능)

  새로운 구현체가 나와도 클라이언트를 바꿀 필요가 없음!
  
  ![image](https://user-images.githubusercontent.com/76834167/136694521-7bb5efd5-d1c1-4c99-a726-be3e08e4feb8.png)


- 다형성 예시 2

  배우 역할(인터페이스) - 다른 구현체로 대체 가능

  로미오의 배우에 줄리엣의 배우가 영향을 받지 않음
  
  ![image](https://user-images.githubusercontent.com/76834167/136694532-f6058e4b-ca09-486a-a299-a653ecb6ed43.png)


- 역할과 구현을 분리
    - 역할 = 인터페이스(먼저 설계) → 안정적으로 변경 없도록 설계하는 것 중요
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체(역할 수행하는 구현 객체 만들기)
    - 클라이언트 → 대상의 역할(인터페이스)만 알면 됨
    - 클라이언트 → 내부 구조 몰라도 됨
    - 클라이언트 → 내부 구조 변경되어도 영향 받지 않음
    - 클라이언트 → 구현 대상 자체 변경해도 영향 받지 않음
- 객체의 협력
    - 클라이언트(요청) → 서버(응답)
    - 클라이언트(요청) → 서버+클라이언트(요청) → 서버(응답)
- 다형성
- 오버라이딩
    - 다형성 인터페이스로 구현한 객체를 실행 시점에 유연하게 변경 가능
    - 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경 가능
    - 예시 1
        ![image](https://user-images.githubusercontent.com/76834167/136694548-942da696-1570-47b6-a98e-8679a285276d.png)

        ```java
        // 위 이미지
        public class MemberService{
        	// memberRepository는 인터페이스에도 의존하고 있지만
          // 두 Repository(구현체)에도 의존 중 : DIP 위반
        	
        	//(1)
        	private MemberRepository memberRepository = new MemoryMemberRepository();
        	//(2)
        	private MemberRepository memberRepository = new JDBCMemberRepository();

        	memberRepository.save(); 
        	//(1)일 때는 MemoryMemberRepository의 save 호출 
        	//(2)일 때는 JDBCMemberRepository의 save 호출
        }
        ```

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP 단일 책임 원칙
    - 하나의 클래스는 하나의 책임만
    - 변경 있을 때 파급 효과가 적어야함

      ex) UI변경, 객체 생성과 사용 분리

- OCP 개방폐쇄 원칙
    - 확장에는 열려있으나 변경에는 닫혀있음
- LSP 리스코프 치환 법칙
    - 행위 중점!
    - 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야함
    - 같은 행위에 대해 반대의 결과가 나오면 안됨

      ex) 자동차 인터페이스 엑셀 = 앞으로 가는 기능, 뒤로 가게 구현하면 LSP 위반

- ISP 인터페이스 분리 원칙
    - 특정 클라이언트 위한 인터페이스 여러개 > 범용 인터페이스 하나
    - 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리 : 쪼개야 함
    - 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
    - 분리된 인터페이스(운전/정비 인터페이스) 자체가 변해도 운전자 클라이언트에 영향 X
    - 인터페이스가 명확해지고 대체 가능성 높아짐
- DIP 의존관계 역전 원칙
    - 구현 클래스 말고 인터페이스에 의존해야함
    - 구현체가 아닌 역할에 의존해야 함
    - 예시 1
      ![image](https://user-images.githubusercontent.com/76834167/136694601-8eb26b1a-11df-4568-bc13-3343ca45aa8c.png)

      
      운전자는 자동차의 역할에만 의존해야지 특정 자동차에 의존하면 안됨

    - 예시 2

      배우는 대본에 의존해야지 특정 상대 배우에 의존하면 안됨

  ## 객체지향 설계와 스프링

    - 스프링 : 다형성 + OCP, DIP 지원
        - DI : 의존관계, 의존성 주입
        - DI 컨테이너 제공
    - 클라이언트 코드 변경 없이 기능 확장
